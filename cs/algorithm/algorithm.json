{
  "conception": {
    "度量": "复杂度",
    "时间复杂度": [
      "问题的规模",
      "数据的初态"
    ],
    "算法": "问题求解步骤的描述"
  },
  "list": {
    "sqlist": "连续存储,随机访问",
    "lilist": {
      "特点": [
        "动态分配",
        "空间利用率低",
        "快速增删"
      ],
      "结构": [
        "单链表",
        "双链表",
        "循环链表",
        "循环双链表",
        "静态链表"
      ]
    },
    "stack": {
      "某一顺序进栈,随时出栈": "卡特兰数",
      "顺序栈": {
        "栈空": "s.top = -1",
        "栈满": "s.top = maxsize - 1"
      },
      "链栈": "",
      "表达式转换": "",
      "共享栈": "两端栈底"
    },
    "queue": {
      "循环队列": {
        "队空": "q.rear == q.front",
        "队满": "(q.rear + 1) % maxsize == q.front",
        "元素个数": "(rear - front + maxsize) % maxsize"
      },
      "链队": "两个指针指向头尾",
      "双端队列": "两端可用,受限操作"
    },
    "char": {
      "结构": "串就是数组",
      "KMP": {
      }
    },
    "array": {
      "matrix": {
        "三元组线性表示法": "int trimat[maxterms+1][3]",
        "伪地址表示法": "int trimat[maxterms+1][2]",
        "邻接表法": "每行的非零元素串联成一个链表,链表节点两个值:val和列号",
        "十字链表法": "每行每列都用一个带头结点的链表表示,每个结点中5个分量:i,j,data,down,right"
      },
      "广义表": {
        "表长": "最上层元素的个数",
        "深度": "表中括号的最大层数"
      }
    },
    "hash": {
      "hash函数": {
        "直接定址法": "ad = f(key)",
        "数字分析法": "ad = f(key(n,m))",
        "平方取中法": "ad = mid(key^2)",
        "除留余数法": "ad = key mod p"
      },
      "冲突处理方法": {
        "线性探测法": "容易产生堆积问题",
        "平方探测法": "d+1 d-1 d+4 d-4 d+9 d-9",
        "链地址法": "hash单元存放单链表表头指针"
      },
      "装填因子": "关键字个数和标长度的比值"
    }
  },
  "tree": {
    "bitree": {
      "完全二叉树": "",
      "满二叉树": "",
      "relation": [
        "n0 = n2 + 1",
        "n = b + 1"
      ],
      "n个结点": "卡特兰数种树",
      "n个结点完全二叉树的深度": "对数底+1,+1对数顶",
      "层次遍历": "辅助队列,出队时访问,分别将左右子树入队.",
      "非递归前序遍历": "建栈入根,loop(s.top != -1){出栈访问并入栈先右后左孩子}",
      "非递归中序遍历": "建栈建指针指根,loop(s.top != -1 || p != NULL){有左孩子继续入根,没左孩子出栈访问并指向右孩子}",
      "非递归后序遍历": "建两栈建一针,loop(s1.top != -1){出栈入栈2,先左后右孩子入栈1},loop(s2.top != -1){出栈访问}",
      "线索二叉树": "tag = 1,指向前驱后继,tag = 0,指向左右子树",
      "二叉树和数的转换": "右子树表示下一个兄弟,左子树表示第一个孩子",
      "二叉排序树": "",
      "平衡二叉树": "",
      "赫夫曼树": {
        "概念": "带权路径WPL最短",
        "特点": [
          "正则二叉树",
          "权值越大离根越近"
        ],
        "构造": "loop{选择最小的两个结点构造棵树,根节点的权值和等于两结点的权值和}"
      },
      "赫夫曼编码": ""
    },
    "BST二叉排序树": {
      "算法": "相似继承算法：被删除节点的直接前驱或直接后继代替被删除节点，然后删除被删除节点的直接前驱或直接后继。",
      "AVL平衡二叉树": {
        "平衡因子": "左高度-右高度",
        "插入": "中间派贿赂算法:插入后破坏平衡,势力大的一方的中间派上台",
        "删除": "相似继承算法+中间派贿赂算法+回溯"
      },
      "RBT红黑树": {
        "民主革命算法": {
          "中下无权者(红色)连结时(相连)": {
            "中层内部分化": "无权者贿赂算法获取领导权",
            "中层内部团结": "中层获得控制权，领导者失去控制权"
          }
        }
      }
    },
    "B树": {
      "m阶": ["最多n=m-1个key","结点最少key = [n/2]"],
      "插入": "插后溢阶,中值飞切",
      "删除": "不能借就合并"
    },
    "B+树": {
      "m阶": ["最多n=m个key","叶子包含全部信息","结点最少key = <n/2>"]
    }
  },
  "graph": {
    "存储结构": {
      "邻接矩阵": {
        "无权图": "0有边,1无边,自身0",
        "有权图": "∞无边,权值有边,自身0"
      },
      "邻接表": {
        "Edge": {
          "dest_node": "指向结点在数组中的位置",
          "next_edge": "下一条边",
          "info": "信息"
        },
        "Node": {
          "info": "信息",
          "first_edge": "第一条边"
        },
        "Graph": {
          "Node nodes[]": "顶点集",
          "edge_num": "边数",
          "node_num": "顶点数"
        }
      },
      "邻接多重表": {
        "Node": {
          "info": "顶点信息",
          "first_edge": "第一条边"
        },
        "Edge": {
          "nodeA": "该边的顶点A",
          "nodeA_next": "顶点A的下一条边",
          "nodeB": "该边的顶点B",
          "nodeB_next": "顶点B的下一条边",
          "info": "信息"
        }
      },
      "十字链表": {
        "Node": {
          "info": "信息",
          "first_in": "第一条入边",
          "first_out": "第一条出边"
        },
        "Edge": {
          "info": "信息",
          "from": "源点",
          "to": "目的点",
          "next_in": "下一条入边",
          "next_out": "下一条出边"
        }
      }
    },
    "DFS(Graph *G,int start_node)": {
      "visited[]": "访问标记数组",
      "p": "辅助边指针,初始化:p  = G -> nodes[v].first_edge",
      "while(p)": "if(visited[p->dest_node] == 0) DFS(G,p->dest_node); p = p -> next_edge"
    },
    "BFS(Graph *G,int start_node)": {
      "visited[]": "访问标记数组",
      "que[],front = 0, rear = 0": "辅助队列,队列中的顶点均已访问",
      "visit&enque(int node)": "visit(node);visited[node] = 1;rear = (rear+1)%maxsize;que[rear]=node",
      "初始化访问start_node": "visit&enque(start_node)",
      "while(front != rear)": {
        "顶点出队": "front = (front+1)%maxsize;current_node = que[front]",
        "while(p)": {
          "如果顶点有目的顶点未访问,则访问顶点并入队": "if(visited[p->dest_node]== 0){visit&enque(p->dest_node)}",
          "p = p -> next_edge": "遍历顶点上的边"
        }
      }
    },
    "无向图-最小生成树": {
      "prim": "正面战场,稠密图",
      "克鲁斯卡尔": "敌后战场,适用于稀疏图"
    },
    "有向图-最短路径": {
      "迪杰斯特拉n^2": {
        "概念": "某点到其余各点的最小距离",
        "组织扩充模型,挑选关系最好近的人成为新成员": [
          "关系最近的人成为新成员",
          "新成员的关系网纳入发展对象,并更新已经是发展对象的人的关系距离"
        ]
      },
      "弗洛伊德n^3": {
        "概念": "各两点之间的距离",
        "模型": "loop(node_num){A[i][j] = min(A[i][j],A[i][mid]+A[mid][j]);if(change)Path[i][j]=mid}"
      }
    },
    "拓扑排序AOV": "循环删除没有入边的点",
    "关键路径AOE": "最迟发生时间是在不推迟整个工程完成的前提下的最迟必须发生时间,剩余时间=最迟发生时间-最早发生时间"
  },
  "sort": {
    "insert": {
      "特点": [
        "无法提前确认某值位置"
      ],
      "direct": {
        "worst": "逆序n^2",
        "best": "有序n"
      },
      "binary": {
        "best": "nlogn",
        "worst": "n^2 "
      },
      "shell": {
        "trait": "unstable",
        "增量序列": "33,17,9,5,3,1,最后必须是1"
      }
    },
    "exchange": {
      "bubble": {
        "结束条件": "一趟排序过程中没有发生交换",
        "worst": "reverse sequence:n^2",
        "best": "sequence:n"
      },
      "quick": {
        "trait": "递归排序,枢纽确定",
        "best": "no sequence:nlogn",
        "worst": "sequence:n^2",
        "O(S)": "logn"
      }
    },
    "select": {
      "simple": "选择最小并和无序部分的第一个交换",
      "heap": {
        "内容": "从不满足堆定义的最后一个点开始下沉运算",
        "适用": "n大"
      }
    },
    "merge_2": "与初始序列无关,best=worst=average=nlogn",
    "radix": "适用于n很大,但是n的关键字很少",
    "external": {
      "merge_k": {
        "m个归并段归并次数": "ceil(log_km)"
      },
      "置换选择排序": "",
      "BMT最佳归并树": "",
      "败者树": {
        "叶子节点": "当前参与归并段的段首记录,叶子节点个数表示参与归并段段数",
        "非叶子结点": "败者序号,出节点胜者归并段序号",
        "比较次数": "ceil(logk)",
        "时间复杂度": "logk"
      },
      "时间复杂度": [
        "每一次归并,所有记录进行两次io",
        "置换选择,所有记录进行两次io"
      ]
    },
    "unstable": [
      "quick",
      "shell",
      "simple",
      "heap"
    ],
    "nlogn": [
      "quick",
      "shell",
      "merge",
      "heap"
    ],
    "pre_ensure_position": [
      "quick",
      "bubble",
      "simple",
      "heap"
    ],
    "no relation with the origin": [
      "simple",
      "binary"
    ]
  }
}